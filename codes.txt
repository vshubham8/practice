#rod cutting app-dynamics
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
int main()
{
    int T;
    cin >> T;
    while(T--) {
        LL N, M, C;
        cin >> N >> M >> C;
        int arr[N];
        int maxLength = 0;
        for(int i = 0; i < N; ++i) {
            cin >> arr[i];
            maxLength = max(maxLength, arr[i]);
        }

        LL ans = 0;
        for(int i = 1; i <= maxLength; ++i) {
            LL totalCost = 0;
            for(int j = 0; j < N; ++j) {
                if(arr[j] < i) {
                    continue;
                }
                int quo = arr[j] / i;
                int cost = quo * i * M;
                int cuts = (quo - 1) + (arr[j] % i > 0);
                cost -= cuts * C;
                if(cost > 0) {
                    totalCost += cost;
                }
            }
            ans = max(ans, totalCost);
        }
        cout << ans << endl;
    }
    return 0;
}

#-------------------
# segmented sieve
// C++ program to print print all primes smaller than 
// n using segmented sieve 
#include <bits/stdc++.h> 
using namespace std; 

// This functions finds all primes smaller than 'limit' 
// using simple sieve of eratosthenes. It also stores 
// found primes in vector prime[] 
void simpleSieve(int limit, vector<int> &prime) 
{ 
    // Create a boolean array "mark[0..n-1]" and initialize 
    // all entries of it as true. A value in mark[p] will 
    // finally be false if 'p' is Not a prime, else true. 
    bool mark[limit+1]; 
    memset(mark, true, sizeof(mark)); 

    for (int p=2; p*p<limit; p++) 
    { 
        // If p is not changed, then it is a prime 
        if (mark[p] == true) 
        { 
            // Update all multiples of p 
            for (int i=p*2; i<limit; i+=p) 
                mark[i] = false; 
        } 
    } 

    // Print all prime numbers and store them in prime 
    for (int p=2; p<limit; p++) 
    { 
        if (mark[p] == true) 
        { 
            prime.push_back(p); 
            cout << p << " "; 
        } 
    } 
} 

// Prints all prime numbers smaller than 'n' 
void segmentedSieve(int n) 
{ 
    // Compute all primes smaller than or equal 
    // to square root of n using simple sieve 
    int limit = floor(sqrt(n))+1; 
    vector<int> prime; 
    simpleSieve(limit, prime); 

    // Divide the range [0..n-1] in different segments 
    // We have chosen segment size as sqrt(n). 
    int low = limit; 
    int high = 2*limit; 

    // While all segments of range [0..n-1] are not processed, 
    // process one segment at a time 
    while (low < n) 
    { 
        if (high >= n) 
        high = n; 
        
        // To mark primes in current range. A value in mark[i] 
        // will finally be false if 'i-low' is Not a prime, 
        // else true. 
        bool mark[limit+1]; 
        memset(mark, true, sizeof(mark)); 

        // Use the found primes by simpleSieve() to find 
        // primes in current range 
        for (int i = 0; i < prime.size(); i++) 
        { 
            // Find the minimum number in [low..high] that is 
            // a multiple of prime[i] (divisible by prime[i]) 
            // For example, if low is 31 and prime[i] is 3, 
            // we start with 33. 
            int loLim = floor(low/prime[i]) * prime[i]; 
            if (loLim < low) 
                loLim += prime[i]; 

            /* Mark multiples of prime[i] in [low..high]: 
                We are marking j - low for j, i.e. each number 
                in range [low, high] is mapped to [0, high-low] 
                so if range is [50, 100] marking 50 corresponds 
                to marking 0, marking 51 corresponds to 1 and 
                so on. In this way we need to allocate space only 
                for range */
            for (int j=loLim; j<high; j+=prime[i]) 
                mark[j-low] = false; 
        } 

        // Numbers which are not marked as false are prime 
        for (int i = low; i<high; i++) 
            if (mark[i - low] == true) 
                cout << i << " "; 

        // Update low and high for next segment 
        low = low + limit; 
        high = high + limit; 
    } 
} 

// Driver program to test above function 
int main() 
{ 
    int n = 100; 
    cout << "Primes smaller than " << n << ":n"; 
    segmentedSieve(n); 
    return 0; 
} 
#---------------
# narray tree - no of ways to traverse this tree
// C++ program to find the number of ways to traverse a 
// n-ary tree starting from the root node 
#include <bits/stdc++.h> 
using namespace std; 

// Structure of a node of an n-ary tree 
struct Node 
{ 
char key; 
vector<Node *> child; 
}; 

// Utility function to create a new tree node 
Node *newNode(int key) 
{ 
Node *temp = new Node; 
temp->key = key; 
return temp; 
} 

// Untility Function to find factorial of given number 
int factorial(int n) 
{ 
if (n == 0) 
	return 1; 
return n*factorial(n-1); 
} 

// Function to calculate the number of ways of travesing 
// the n-ary starting from root. 
// This function is just a modified breadth-first search. 
// We can use a depth-first search too. 
int calculateWays(Node * root) 
{ 
int ways = 1; // Initialize result 

// If the tree is empty there is no way of traversing 
// the tree. 
if (root == NULL) 
	return 0; 

// Create a queue and enqueue root to it. 
queue<Node *>q; 
q.push(root); 

// Level order traversal. 
while (!q.empty()) 
{ 
		// Dequeue an item from queue and print it 
		Node * p = q.front(); 
		q.pop(); 

		// The number of ways is the product of 
		// factorials of number of children of each node. 
		ways = ways*(factorial(p->child.size())); 

		// Enqueue all childrent of the dequeued item 
		for (int i=0; i<p->child.size(); i++) 
			q.push(p->child[i]); 
	} 

return(ways); 
} 

// Driver program 
int main() 
{ 
/* Let us create below tree 
*		 A 
*		 / / \ \ 
*	 B F D E 
*	 / \	 | /|\ 
*	 K J G C H I 
*	 /\		 \ 
* N M		 L 
*/

Node *root = newNode('A'); 
(root->child).push_back(newNode('B')); 
(root->child).push_back(newNode('F')); 
(root->child).push_back(newNode('D')); 
(root->child).push_back(newNode('E')); 
(root->child[0]->child).push_back(newNode('K')); 
(root->child[0]->child).push_back(newNode('J')); 
(root->child[2]->child).push_back(newNode('G')); 
(root->child[3]->child).push_back(newNode('C')); 
(root->child[3]->child).push_back(newNode('H')); 
(root->child[3]->child).push_back(newNode('I')); 
(root->child[0]->child[0]->child).push_back(newNode('N')); 
(root->child[0]->child[0]->child).push_back(newNode('M')); 
(root->child[3]->child[2]->child).push_back(newNode('L')); 

cout << calculateWays(root); ; 

return 0; 
} 
#---------------
# diameter of an n ary tree
// C++ program to find the height of an N-ary 
// tree 
#include <bits/stdc++.h> 
using namespace std; 

// Structure of a node of an n-ary tree 
struct Node 
{ 
	char key; 
	vector<Node *> child; 
}; 

// Utility function to create a new tree node 
Node *newNode(int key) 
{ 
	Node *temp = new Node; 
	temp->key = key; 
	return temp; 
} 

// Utility function that will return the depth 
// of the tree 
int depthOfTree(struct Node *ptr) 
{ 
	// Base case 
	if (!ptr) 
		return 0; 

	int maxdepth = 0; 

	// Check for all children and find 
	// the maximum depth 
	for (vector<Node*>::iterator it = ptr->child.begin(); 
						it != ptr->child.end(); it++) 

		maxdepth = max(maxdepth , depthOfTree(*it)); 

	return maxdepth + 1; 
} 

// Function to calculate the diameter 
// of the tree 
int diameter(struct Node *ptr) 
{ 
	// Base case 
	if (!ptr) 
		return 0; 

	// Find top two highest children 
	int max1 = 0, max2 = 0; 
	for (vector<Node*>::iterator it = ptr->child.begin(); 
						it != ptr->child.end(); it++) 
	{ 
		int h = depthOfTree(*it); 
		if (h > max1) 
		max2 = max1, max1 = h; 
		else if (h > max2) 
		max2 = h; 
	} 

	// Iterate over each child for diameter 
	int maxChildDia = 0; 
	for (vector<Node*>::iterator it = ptr->child.begin(); 
						it != ptr->child.end(); it++) 
		maxChildDia = max(maxChildDia, diameter(*it)); 

	return max(maxChildDia, max1 + max2 + 1); 
} 

// Driver program 
int main() 
{ 
	/* Let us create below tree 
	*		 A 
	*		 / / \ \ 
	*	 B F D E 
	*	 / \	 | /|\ 
	*	 K J G C H I 
	*	 /\		 \ 
	* N M		 L 
	*/

	Node *root = newNode('A'); 
	(root->child).push_back(newNode('B')); 
	(root->child).push_back(newNode('F')); 
	(root->child).push_back(newNode('D')); 
	(root->child).push_back(newNode('E')); 
	(root->child[0]->child).push_back(newNode('K')); 
	(root->child[0]->child).push_back(newNode('J')); 
	(root->child[2]->child).push_back(newNode('G')); 
	(root->child[3]->child).push_back(newNode('C')); 
	(root->child[3]->child).push_back(newNode('H')); 
	(root->child[3]->child).push_back(newNode('I')); 
	(root->child[0]->child[0]->child).push_back(newNode('N')); 
	(root->child[0]->child[0]->child).push_back(newNode('M')); 
	(root->child[3]->child[2]->child).push_back(newNode('L')); 

	cout << diameter(root) << endl; 

	return 0; 
} 
#---------------
#---------------
#---------------
