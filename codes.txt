
/*
#rod cutting app-dynamics
typedef long long LL;
int main()
{
    int T;
    cin >> T;
    while(T--) {
        LL N, M, C;
        cin >> N >> M >> C;
        int arr[N];
        int maxLength = 0;
        for(int i = 0; i < N; ++i) {
            cin >> arr[i];
            maxLength = max(maxLength, arr[i]);
        }

        LL ans = 0;
        for(int i = 1; i <= maxLength; ++i) {
            LL totalCost = 0;
            for(int j = 0; j < N; ++j) {
                if(arr[j] < i) {
                    continue;
                }
                int quo = arr[j] / i;
                int cost = quo * i * M;
                int cuts = (quo - 1) + (arr[j] % i > 0);
                cost -= cuts * C;
                if(cost > 0) {
                    totalCost += cost;
                }
            }
            ans = max(ans, totalCost);
        }
        cout << ans << endl;
    }
    return 0;
}

#-------------------
# segmented sieve
// C++ program to print print all primes smaller than 
// n using segmented sieve 
#include <bits/stdc++.h> 
using namespace std; 

// This functions finds all primes smaller than 'limit' 
// using simple sieve of eratosthenes. It also stores 
// found primes in vector prime[] 
void simpleSieve(int limit, vector<int> &prime) 
{ 
    bool mark[limit+1]; 
    memset(mark, true, sizeof(mark)); 
    for (int p=2; p*p<limit; p++) 
    { 
        if (mark[p] == true) 
        { 
            for (int i=p*2; i<limit; i+=p) 
                mark[i] = false; 
        } 
    } 
    for (int p=2; p<limit; p++) 
    { 
        if (mark[p] == true) 
        { 
            prime.push_back(p); 
            cout << p << " "; 
        } 
    } 
} 

// Prints all prime numbers smaller than 'n' 
void segmentedSieve(int n) 
{ 
    int limit = floor(sqrt(n))+1; 
    vector<int> prime; 
    simpleSieve(limit, prime); 
    int low = limit; 
    int high = 2*limit; 
    while (low < n) 
    { 
        if (high >= n) 
        high = n; 
        bool mark[limit+1]; 
        memset(mark, true, sizeof(mark)); 
        for (int i = 0; i < prime.size(); i++) 
        { 
            int loLim = floor(low/prime[i]) * prime[i]; 
            if (loLim < low) 
                loLim += prime[i]; 
            for (int j=loLim; j<high; j+=prime[i]) 
                mark[j-low] = false; 
        } 
        for (int i = low; i<high; i++) 
            if (mark[i - low] == true) 
                cout << i << " "; 
        low = low + limit; 
        high = high + limit; 
    } 
} 
// Primes less than n
segmentedSieve(n); 
#---------------
# narray tree - no of ways to traverse this tree
// C++ program to find the number of ways to traverse a 
// n-ary tree starting from the root node 

struct Node 
{ 
char key; 
vector<Node *> child; 
}; 

Node *newNode(int key) 
{ 
Node *temp = new Node; 
temp->key = key; 
return temp; 
} 

int factorial(int n) 
{ 
if (n == 0) 
    return 1; 
return n*factorial(n-1); 
} 

int calculateWays(Node * root) 
{ 
int ways = 1; 
if (root == NULL) 
    return 0; 
queue<Node *>q; 
q.push(root); 
while (!q.empty()) 
{ 
        Node * p = q.front(); 
        q.pop(); 
        ways = ways*(factorial(p->child.size())); 
        for (int i=0; i<p->child.size(); i++) 
            q.push(p->child[i]); 
    } 

return(ways); 
} 

// Driver program 
int main() 
{ 
cout << calculateWays(root); ; 
return 0; 
} 
#---------------
# diameter of an n ary tree
// C++ program to find the height of an N-ary tree 
#include <bits/stdc++.h> 
using namespace std; 

// Structure of a node of an n-ary tree 
struct Node 
{ 
    char key; 
    vector<Node *> child; 
}; 

// Utility function to create a new tree node 
Node *newNode(int key) 
{ 
    Node *temp = new Node; 
    temp->key = key; 
    return temp; 
} 

// Utility function that will return the depth 
// of the tree 
int depthOfTree(struct Node *ptr) 
{ 
    if (!ptr) 
        return 0; 

    int maxdepth = 0; 

    for (vector<Node*>::iterator it = ptr->child.begin(); 
                        it != ptr->child.end(); it++) 

        maxdepth = max(maxdepth , depthOfTree(*it)); 

    return maxdepth + 1; 
} 

int diameter(struct Node *ptr) 
{ 
    if (!ptr) 
        return 0; 
    int max1 = 0, max2 = 0; 
    for (vector<Node*>::iterator it = ptr->child.begin(); 
                        it != ptr->child.end(); it++) 
    { 
        int h = depthOfTree(*it); 
        if (h > max1) 
        max2 = max1, max1 = h; 
        else if (h > max2) 
        max2 = h; 
    } 

    int maxChildDia = 0; 
    for (vector<Node*>::iterator it = ptr->child.begin(); 
                        it != ptr->child.end(); it++) 
        maxChildDia = max(maxChildDia, diameter(*it)); 

    return max(maxChildDia, max1 + max2 + 1); 
} 

// Driver program 
int main() 
{ 
    cout << diameter(root) << endl; 
    return 0; 
} 
#---------------
# coin change gfg
int count( int S[], int m, int n ) 
{ 
    int i, j, x, y; 
    int table[n + 1][m]; 
    
    for (i = 0; i < m; i++) 
        table[0][i] = 1; 
    for (i = 1; i < n + 1; i++) 
    { 
        for (j = 0; j < m; j++) 
        { 
            x = (i-S[j] >= 0) ? table[i - S[j]][j] : 0; 

            y = (j >= 1) ? table[i][j - 1] : 0; 

            table[i][j] = x + y; 
        } 
    } 
    return table[n][m - 1]; 
} 
// Driver Code 
int main() 
{ 
    int arr[] = {1, 2, 3}; 
    int m = sizeof(arr)/sizeof(arr[0]); 
    int n = 4; 
    cout << count(arr, m, n); 
    return 0; 
} 
#---------------
// /*
// BNY Mellon IITK 2018
// Given N, find the number of ordered pairs of positive integers (x,y) satisfying
// the following relation:
// 1/x + 1/y = 1/N!
// 0 <= N <= 100000
// time O(N * log log N)
// space O(N)
const int mod = 1E9 + 7;

int main() {
    int n; cin >> n;
    int ans = 1;
    vector<bool> isprime(n + 1, true);
    for (int i = 2; i <= n; i++) {
        if (isprime[i]) {
            for (int imul = 2 * i; imul <= n; imul += i) {
                isprime[imul] = false;
            }
            int ncopy = n, ipower = 0;
            while (ncopy) ipower += ncopy /= i;
            ans = (1LL + 2 * ipower) * ans % mod;
        }
    }
    cout << ans;
    return 0;
}
#---------------
// /*
// Walmart Labs IIT Dhanbad 2018
// Given strings A and B, find the minimum number of manipulation done in string A
// to achieve the following:
// 1. A is a palindrome
// 2. B is a substring in A
// Here manipulation is defined as changing a character to some other character
// 1 <= String Lengths <= 5000
// O(N^2)
// 

int palSubstring(string &a, string &b) {
    int n = a.size(), m = b.size();
    int ans = n + 1;
    for (int i = 0; i <= n - m; i++) {
        int cost = 0, error = 0;
        string s = a;
        for (int j = 0; j < m; j++) {
            if (s[i + j] != b[j]) {
                s[i + j] = b[j];
                cost++;
            }
        }
        for (int j = 0; j < n / 2; j++) {
            if (s[j] != s[n - 1 - j]) {
                if (j < max(i, n - m - i)) cost++;
                else error++;
            }
        }
        if (ans > cost and not error) {
            ans = cost;
        }
    }
    return (ans > n ? -1 : ans);
}

int main() {
    int t; cin >> t;
    while (t--) {
        string a, b; cin >> a >> b;
        cout << palSubstring(a, b) << '\n';
    }
    return 0;
}
#-----------------------

// /*
// Given a source string and a target string, find the minimum length of a circular
// substring of the source string which contains the target string. If no such 
// substring exists, return -1. Circular substring means any substring of the
// rotated source string.
// For e.g. if source string is "shit" then all circular strings will be
// {"shit", "hits", "itsh", "tshi"}. String x contains string y if all characters 
// appear at least the same number of times in x as it appears in y.
// E.g. for source "kecrha" and target "ack", the best possible answer can be for
// the circular string "hakecr" where the relevant substring is "akec" containing 
// "ack". Hence the final answer is 4
// 1 <= length of strings <= 100000
// O(N + 26) solution
// 
int CircularSubstring(string source, string target) {
    int n = source.size();
    source += source;
    int a[26] = {}, nz = 0;
    for (char c : target) {if (not a[c - 'a']++) {nz++;}}
    int min_len = 2 * n;
    for (int i = 0, j = 0; i < 2 * n; i++) {
        if (not --a[source[i] - 'a']){nz--;}
        while (a[source[j] - 'a'] < 0) {
            a[source[j++] - 'a']++;
        }
        if (not nz) {min_len = min(min_len, i - j + 1);}
    }
    return min_len > n ? -1 : min_len;
}

int main() {
    cout << CircularSubstring("kecrha", "ack") << '\n';
    return 0;
}

#-----------------------

// /*
// ThoughtSpot IITK 2018
// Given n, find the sum of number of inversions over all derangements of length n.
// As the number can be very large, print it modulo 1000000007.
// Inversion in array A is a pair (i,j) where i < j and A[i] > A[j].
// Derangement of length n is a permutation of 1..n such that A[i] != i for any i.
// 1 <= n <= 20
// Formula taken from here - https://oeis.org/A216239
// O(n)
// 
int countDerangementInversions(int n) {
    const int MOD = 1E9 + 7;
    const int inv12 = (MOD + 1) / 12;
    long long ans = 0;
    for (long long k = n - 1, v = n * (n - 1); k--; ) {
        long long x = v * (3 * n + k) * (n - k - 1) % MOD;
        if (k & 1) x = MOD - x;
        ans = (ans + x) % MOD;
        v = v * k % MOD;
    }
    return ans * inv12 % MOD;
}
#-----------------------
// /*
// Samsung Delhi IITD 2018
// Initially you have H amount of energy and D distance to travel. You may travel
// with any of the given 5 speeds. But you may only travel in units of 1 km. For 
// each km distance traveled, you will spend corresponding amount of energy.
// e.g. the given speeds are:
// Cost of traveling 1 km: [4, 5, 2, 3, 6]
// Time taken to travel 1 km: [200, 210, 230, 235, 215]
// Find minimum time required to cover total D km with remaining H >= 0
// 1 <= H <= 4000
// 1 <= D <= 1000
// 

const int INF = 2E9;
int dp[4040][1010][5];
inline int fun(int i, int j, int k, vector<int> &a, vector<int> &b) {
    if (i < 0) return INF;
    if (j == 0) return 0;
    if (k < 0) return INF;
    if (dp[i][j][k] != -1) return dp[i][j][k];
    return dp[i][j][k] = min(fun(i, j, k - 1, a, b), b[k] + fun(i - a[k], j - 1, k, a, b));
}
int getMinTime(vector<int> &cost, vector<int> &time, int H, int D) {
    memset(dp, -1, sizeof dp);
    return fun(H, D, 4, cost, time);
}
int main() {
    int t (14);
    vector<int> cost {4, 5, 2, 3, 6};
    vector<int> time {200, 210, 230, 235, 215};
    cout << getMinTime(cost, time, t, 4);
    return 0;
}
// #-----------------------

// /*
Nutanix IITD 2018
We are given the inorder and postorder traversal of a Binary tree. The data in 
the nodes are alphanumeric characters. Had to classify the tree shape into one 
of the following types:
/ (forward slash) if the shape of tree is like a forward slash
\ (Backward slash) if the shape is like a backward slash
< (less than) if the tree shape is like
> (greater than)
^ (exponent symbol) if the shape of tree is like
# (hash) if none of the above
Below figures are for further clarity (a, b, c represent nodes) :
         a         a               a         a
        /           \             /           \            a
(/)    b      (\)    b      (<)  b      (>)    b    (^)   / \    (#) all other
      /               \           \           /          b   c
     c                 c           c         c

bool check(string s, string t) { 
    for (int i = s.size(); --i; ) {
        string tir(t.substr(0, i));
        reverse(tir.begin(), tir.end());
        if (s.substr(0, i) == tir and s.substr(i) == t.substr(i)) {
            return true;
        }
    }
    return false;
}

string solve() {
    string s, t; cin >> s >> t;
    string sr(s); reverse(sr.begin(), sr.end());
    string tr(t); reverse(tr.begin(), tr.end());
    if (s == t) return "/"; // T .. T
    if (s == tr) return "\\"; // > .. <
    if (check(s, t)) return "<"; // >T .. <T
    if (check(sr, t)) return ">"; // >T .. T<
    if (check(sr, tr)) return "^"; // T> .. T<
    return "#"; // else
}

int main() {
    int t; cin >> t;
    while (t--) {
        cout << solve() << '\n';
    }
    return 0;
}

#-----------------------

// /*
// BNY Mellon IITK 2018
// Given an encoded string and the Huffman codes for each character, print the
// decoded string. Huffman codes are provided as an array of strings where the key-
// value pair are separated by a tab and appear as an array element. It is ensured
// that the key will be a character and value will be a binary string.
// average O(n) space and time
// Replacing unordered_map with map gives O(n log n) time and O(n) space
// 
#include <cassert>
string huffmanDecode(vector<string> codes, string encoded) {
    int n = codes.size();
    unordered_map<string,char> ids;
    for (int i = 0; i < n; i++) {
        char key = codes[i][0];
        string val = codes[i].substr(2);
        ids[val] = key;
    }
    string decoded = "", cur = "";
    for (char c : encoded) {
        cur += c;
        if (ids.find(cur) != ids.end()) {
            decoded += ids[cur];
            cur = "";
        }
    }
    if (cur != "") {
        decoded += ids[cur];
    }
    return decoded;
}

int main() {
    assert(huffmanDecode(
        {"a\t01", "b\t110", "c\t101", "d\t0010", "\n\t1111"},
        "1100010110111101") == "bdb\na");
    return 0;
}

#-----------------------

// /*
// Nutanix IISc 2018
// https://www.codechef.com/problems/CLKLZM
// O(n + m log m)
// 

#define int long long
signed main() {
    ios_base::sync_with_stdio(false); cin.tie(NULL);
    int cases; cin >> cases;
    while (cases--) {
        int n, m; cin >> n >> m;
        
        vector<int> a(n);
        for (int i = 0; i < n; i++) {
            cin >> a[i];
        }
        vector<pair<pair<int,int>,int>> b(m);
        for (int i = 0; i < m; i++) {
            int l, r, k; cin >> l >> r >> k;
            b[i] = {{l - 1, r - 1}, k};
        }
        sort(b.begin(), b.end(), [](pair<pair<int,int>,int> l, pair<pair<int,int>,int>)
            if (l.first.first == r.first.first) return l.first.second > r.first.second;
            return l.first.first < r.first.first;
        });
        vector<int> c(n);
        int j = 0, ext = 0, ans = 0, fl = 0;
        priority_queue<pair<int,int>> q;
        for (int i = 0; i < n; i++) {
            a[i] -= ext;

            while (j < m and b[j].first.first <= i) {
                q.push({b[j].first.second, b[j].second});
                j++;
            }
            int r, k;
            while (a[i] > 0 and not q.empty()) {
                tie(r, k) = q.top(); q.pop();
                if (r < i) continue;
                
                if (k <= a[i]) {
                    ans += k;
                    ext += k;
                    c[r] += k;
                    a[i] -= k;
                }
                else {
                    ans += a[i];
                    ext += a[i];
                    c[r] += a[i];
                    q.push({r, k - a[i]});
                    a[i] = 0;
                }
            }
            if (a[i] > 0) {
                fl = 1;
                break;
            }
            ext -= c[i];
        }
        if (fl) cout << "NO";
        else cout << "YES " << ans;
        cout << '\n';
    }
    return 0;
}
#-----------------------
// /*
// Flipkart IIT Kanpur 2018
// Given a limited number of coins of denominations 1, 5, 10, and 25
// as p, q, r, and s respectively, return the maximum number of coins 
// which can be used to reach a target "price", if possible.
// Your function should return a vector of length 4 representing the
// number of coins used for the denominations 1, 5, 10, 25 respectively.
// If no solution is possible, return a vector of 0s.
// 0 <= price, p, q, r, s <= 100000
// 
#define int long long

vector<int> dummy(4);
vector<int> greedy(int price, int p, int q, int r, int s) {
    if (price <= p) return {price, 0, 0, 0};
    price -= p;

    if (price <= 5 * q) {
        if (price % 5 == 0) return {p, price / 5, 0, 0};
        return dummy;
    }
    price -= 5 * q;

    if (price <= 10 * r) {
        if (price % 10 == 0) return {p, q, price / 10, 0};
        return dummy;
    }
    price -= 10 * r;

    if (price <= 25 * s) {
        if (price % 25 == 0) return {p, q, r, price / 25};
        return dummy;
    }

    return dummy;
}
vector<int> getMaxCoins(int price, int p, int q, int r, int s) {
    map<int, set<vector<int>>> mp;
    for (int i = 0; i <= 25; i++) {
        for (int j = 0; j <= 5; j++) {
            for (int k = 0; k <= 3; k++) {
                if (p >= i and q >= j and r >= k) {
                    auto counts = greedy(price, p - i, q - j, r - k, s);
                    if (counts != dummy) {
                        int count = 0;
                        for (int c : counts) {
                            count += c;
                        }
                        mp[-count].insert(counts);
                    }
                }
            }
        }
    }
    if (mp.empty()) return dummy;
    auto feasible = mp.begin()->second;
    if (feasible.empty()) return dummy;
    return *feasible.begin();
}

signed main() {
    int denominations[] = {1, 5, 10, 25};
    vector<int> counts = getMaxCoins(99, 98, 0, 0, 1);
    
    for (int i = 0; i < 4; i++) {
        cout << "Number of coins of denomination " << denominations[i] << " = " << counts[i] << '\n';
    }
    return 0;
}

#-----------------------

// /*
// Goldman Sachs IITD 2018
// We are given an array of size N, we can delete a subset b1b2b3...bk from the 
// array if 2^b1 + 2^b2 + …..2^bk = 2^x for non-negative integer x where ^ is the
// power operator. Find the minimum number of steps required to delete the 
// complete array.
// 0 <= ai <= 1000000
// 1 <= N <= 1000000
// Approach: The problem boils down to finding the number of set-bits in 
// the summation 2^a0 + 2^a1 + 2^a2 + ... which can be done by counting the number
// of ai's for each ai and then using the same logic as you do for adding up two 
// decimal numbers but instead of base-10, use base-2
// O(N + L + log L) where L is the upper bound on value of ai
// 
int minBin(vector<int> a) {
    const int L = 1E6; // max possible value of ai
    vector<int> cnt(L + 30);
    for (int ai : a) cnt[ai]++;

    int ans = (cnt[0] & 1);
    for (int i = 1; i < L + 30; i++) {
        cnt[i] += cnt[i - 1] >> 1;
        if (cnt[i] & 1) ans++;
    }
    return ans;
}
// #-----------------------
// /*
// Walmart Labs IIT Dhanbad 2018
// For a given number A, following operations are allowed:
// 1. A -> A + 1
// 2. A -> A - 1 (provided A > 0)
// 3. A -> 2 * A
// Cost of operation 1 and 2 is equal to A and cost of operation 2 is B.
// Find the minimum cost to reach X starting from 0.
// 1 <= X <= 100000
// 0 <= A, B <= 1000000
// O(X)
// 
inline void Min(int &a, int b) {
    if (a > b) a = b;
}
int find_min_cost(int A, int B, int X) {
    vector<int> ans(4 * X, -1);
    ans[0] = 0;
    for (int i = 1; i <= X; i++) {
        ans[i] = ans[i - 1] + A;
        
        if (i & 1) Min(ans[i], ans[i >> 1] + B + A);
        else Min(ans[i], ans[i >> 1] + B);
        
        if (ans[i + 1] != -1) Min(ans[i], ans[i + 1] + A);
        ans[i << 1 | 1] = ans[i] + B + A;
        ans[i << 1] = ans[i] + B;
    }
    return ans[X];
}
// #-----------------------
// /*
// Walmart Labs IITG 2018
// Following operations are defined:
// 1. X -> X + 1
// 2. X -> X - 1
// Cost of operation 1 and 2 are cost_inc and cost_dec respectively. Given a number
// N, find the minimum cost to reach a number M such that M can be represented as a
// sum of two different single-digit odd prime numbers with positive powers.
// O(k*logn) where k is very small. For n <= 1E8, there are less than 500 possible M
// 
#include <set>
int minCostOddPrimeSum(int n, int cost_dec, int cost_inc) {
    const int N = 1E6; // N represents the upper bound on input n. Adjust.
    const int LIM = 2 * N + 10;

    std::set<int> st;
    for (int p : {3, 5, 7}) {
        for (int q : {3, 5, 7}) {
            if (p <= q) continue;
            int pi = p;
            while (pi <= LIM) {
                int qj = q;
                while (pi + qj <= LIM) {
                    st.insert(pi + qj);
                    qj *= q;
                }
                pi *= p;
            }
        }
    }

    int lo = 0, hi;
    for (int x : st) {
        if (x == n) {
            return 0;
        }
        
        if (x < n) {
            lo = x;
        }
        else {
            hi = x;
            break;
        }
    }
    
    int ans = (hi - n) * cost_inc;
    int ans1 = (n - lo) * cost_dec;
    if (lo and ans > ans1) ans = ans1;
    return ans;
}
// #-----------------------
// /*
// Flipkart IIT Kanpur 2018
// Given two vectors of length n representing the x and y 
// coordinates of cartesian points, find the minimum possible area 
// of a rectangle which can be formed using four distinct points which has sides parallel to the x & y axis.
// If non rectangle can be formed, return -1.
// 1 <= n <= 1000
// 
#include <bits/stdc++.h>
using namespace std;
#define int long long

const int INF = 1E15;
int getMinArea(vector<int> x, vector<int> y) {
    map<pair<int,int>, set<int>> m;
    int n = x.size();
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (x[i] == x[j]) {
                m[{min(y[i], y[j]), max(y[i], y[j])}].insert(x[i]);
            }
        }
    }
    
    int ans = INF;
    for (auto &p : m) {
        int a = p.first.second - p.first.first;
        vector<int> xs(p.second.begin(), p.second.end());
        int sz = xs.size();
        for (int i = 1; i < sz; i++) {
            ans = min(ans, a * (xs[i] - xs[i - 1]));
        }
    }
    return (ans < INF ? ans : -1);
}

signed main() {
    cout << getMinArea(
        {1,1,2,2,3,3,4,4},
        {1,3,1,8,1,8,1,3}
    ) << '\n';
    return 0;
}

// #-----------------------

// /*
// Nutanix IISc 2018
// Given destination x = M, initial positions of participants x[1], x[2], .. x[N],
// and constant speeds of participants y[1], y[2], .. y[N], the race goes on in a
// single line formation such that noone can overtake someone else. Hence, if a 
// person with higher speed meets another person with a lower speed during the race
// then he starts moving at the lower speed for rest of the race.
// Find the number of groups that will reach the destination. If two people meet
// at the destination, they are also assumed to form a group.
// 1 <= #testcases <= 10
// 0 <= N <= 10^5
// 1 <= M <= 10^6
// 1 <= x[i] < M
// 1 <= y[i] <= 10^6
// All x[i] are guaranteed to be different.
// O(n log n)
// 

#include <bits/stdc++.h>
using namespace std;
const double eps = 1E-12;

int main() {
    int t; cin >> t;
    while (t--) {
        int n, m; cin >> n >> m;
        vector<int> x(n);
        for (int i = 0; i < n; i++) {
            cin >> x[i];
        }

        vector<pair<int,double>> xts;
        for (int i = 0; i < n; i++) {
            double yi; cin >> yi;
            xts.emplace_back(-x[i], (m - x[i]) / yi);
        }
        sort(xts.begin(), xts.end());

        int ans = 0;
        double cur = 0;
        for (auto xt : xts) {
            if (xt.second > cur + eps) {
                cur = xt.second;
                ans++;
            }
        }
        cout << ans << '\n';
    }
}

// #-----------------------

// /*
// IITR Razorpay 2018
// Consider a prison gate having N horizontal rods and M vertical rods.
// You are also provided with two vectors hor and ver containing the 
// row number of missing horizontal rods and vertical rods respectively.
// Return the area of biggest hole in the prison gate.
// 1 <= N, M <= 1000000
// 1 <= hor[i] <= N
// 1 <= ver[i] <= M
// All the elements of a vector are distinct
// O(N + M)
// SKIPPING... O(AlogA + BlogB) where A = hor.size() and B = ver.size()
// 
#include<bits/stdc++.h>
using namespace std;

long int prison(int n, int m, vector<int> hor, vector<int> ver) {
    vector<bool> xs(n + 1), ys(m + 1);
    for (int h : hor) xs[h] = true;
    for (int v : ver) ys[v] = true;
    int xm = 0, ym = 0;
    for (int i = 1, j = 0; i <= n; i++) {
        if (not xs[i]) j = 0;
        else xm = max(xm, ++j);
    }
    for (int i = 1, j = 0; i <= m; i++) {
        if (not ys[i]) j = 0;
        else ym = max(ym, ++j);
    }
    return (long int)(xm + 1) * (ym + 1);
}

int main() {
    cout << prison(10, 10, {}, {});
    return 0;
}

// #-----------------------

// /*    
// Cohesity : IITD
// Scientific_Farmer:
// Harry Stine is one of the wealthiest farmers in the world (net worth of $3.5 billion). Stine is known as a math wiz
// and adopts unique practices when planting seeds and harvesting crops. For instance, his fields are always arranged
// in a circular layout to promote better pollination, e.g., if there are n fields, then the 1st field and the nth field are
// adjacent to each other. Also, his crop harvester machines never harvest two adjacent fields on the same day to
// minimize damage to standing crops. Each field produces a certain yield (value) of crops. Given a list of non-negative
// integers representing the yield of each field, determine the maximum yield of crops that Harry can harvest in a day.
// ==> Maximum sum in circular array such that no two elements are adjacent
// Solution Approach:
//     recursive solution with memoization
    
//     recurse(idx,prev,frst)
//     we are at index = idx, we need to decice whether to take
//     a[idx] or not. prev indicates a[idx - 1] is taken or not
//     frst == 1 : a[1] is taken
//     frst == 0 : a[1] is not taken
//     few examples: from other sources:
    
//     3
//     4 2 3
//     => 4
    
//     4
//     1 2 3 1
//     => 4
    
//     6
//     1 2 3 4 5 1
//     => 9
// 

#include <bits/stdc++.h>
using namespace std;
int n;
int dp[100009][2][2];
int a[100009];

int recurse(int idx,bool prev,bool frst) {
    if(idx == n) {
        if(!prev and !frst) {
            return a[idx];
        }else {
            return 0;
        }
    }
    if(dp[idx][prev][frst] != -1) return dp[idx][prev][frst];    
    int res = 0;        // all numbers are non negative
    if(prev == false) {
        // take a[idx]
        res = max(res,recurse(idx+1,true,frst) + a[idx]);    
        // not take a[idx]
        res = max(res,recurse(idx+1,false,frst));
    }else {
        // not take a[idx]
        res = max(res,recurse(idx+1,false,frst));
    }
    return dp[idx][prev][frst] = res;
}

int main() {
    cin >> n;
    for(int idx = 1;idx<=n;idx++) {
        cin >> a[idx];
    }
    memset(dp,-1,sizeof dp);
    // call two times
    // once not taking the first element
    // once taking the first element
    int res = max(recurse(2,false,false) , recurse(2,true,true) + a[1]);
    cout << res << endl;
}

// #-----------------------

// /*
// IITR Flipkart 2018
// Given a string s, return a string t satisfying the following:
// 1. s contains t
// 2. t is a palindrome
// 3. t is largest possible
// If multiple t exists, return the lexicographically smallest t.
// 1 <= |s| <= 100000
// O(|s| + 26)
// 
string smallestRestrictedPalindrome(string s) {
    int c[26] = {};
    for (char ch : s) c[ch - 'a']++;
    string t = "";
    for (int i = 0; i < 26; i++) {
        for (int j = c[i] >> 1; j--; ) {
            t += (char)('a' + i);
        }
    }
    int fl = 0;
    for (int i = 0; not fl and i < 26; i++) {
        if (c[i] & 1) {
            t += (char)('a' + i);
            fl = 1;
        }
    }
    int n = t.size() - fl;
    for (int i = n; i--; ) {
        t += t[i];
    }
    return t;
}

// #-----------------------

// /*
// Fractal Analytics IITK 2018
// Maintain a stack which can handle the following operations:
// "push k": Push k at the top of stack
// "pop": Remove the topmost element from the stack
// "inc e k": Add k to the bottom e elements of the stack
// pop is never called on an empty stack.
// Given a vector of strings where each string is an operation as
// defined above, print the top element after every operation. If
// the stack is empty at some point, print "EMPTY" instead.
// 1 <= #operations <= 1E5
// 1 <= k <= size of stack at the time of operation
// 
#include <bits/stdc++.h>
using namespace std;

void superStack(vector<string> ops) {
    int n = ops.size();
    vector<int> a(n), b(n);

    int k = 0;
    for (string op : ops) {
        stringstream strin(op);
        
        string optype;
        strin >> optype;
        if (optype == "push") {
            int x;
            strin >> x;
            a[k++] = x;
        }
        if (optype == "pop") {
            if (--k) b[k - 1] += b[k];
            b[k] = 0;
        }
        if (optype == "inc") {
            int x, y;
            strin >> x >> y;
            b[x - 1] += y;
        }

        if (not k) {
            cout << "EMPTY";
        }
        else {
            cout << a[k - 1] + b[k - 1];
        }
        cout << " ";
    }
}

int main() {
    vector<string> operations = {
        "push 4", "pop", "push 3", "push 5", "inc 2 1",
        "pop", "push 5", "push -1", "inc 1 5", "pop"
    };
    superStack(operations);
    return 0;
}

// #-----------------------

// /*
// Flipkart IIT Kanpur 2018
// https://www.hackerrank.com/contests/hack-it-to-win-it-paypal/challenges/q4-traveling-is-fun
// 

#include <bits/stdc++.h>
using namespace std;
#define int long long

struct dsu {
    vector<int> par, sz;
    dsu(int n): par(n), sz(n, 1) {
        for (int i = 0; i < n; i++) {
            par[i] = i;
        }
    }
    int root(int a) {
        if (a == par[a]) return a;
        return par[a] = root(par[a]);
    }
    void merge(int a, int b) {
        a = root(a);
        b = root(b);
        if (a == b) return;
        if (sz[a] < sz[b]) swap(a, b);
        sz[a] += sz[b];
        par[b] = a;
    }
};

vector<int> findReachable(int n, int g, vector<int> from, vector<int> to) {
    dsu d(n);
    for (int k = g + 1; k <= n; k++) {
        for (int x = 2 * k; x <= n; x += k) {
            d.merge(x - 1, x - k - 1);
        }
    }

    int m = from.size();
    vector<int> ans;
    for (int i = 0; i < m; i++) {
        ans.push_back(d.root(from[i] - 1) == d.root(to[i] - 1));
    }
    return ans;
}

signed main() {
    vector<int> from {10, 4, 3, 6};
    vector<int> to {3, 6, 2, 9};
    vector<int> reachable = findReachable(10, 1, from, to);
    for (int i = 0; i < 4; i++) {
        cout << "From " << from[i] << " to " << to[i] << ": ";
        cout << (reachable[i] ? "Possible" : "Not possible") << '\n';
    }
    return 0;
}

// #-----------------------

// /*
// Rivigo IITK 2018
// There is a gate in an amusement park. There is an entrance queue and an exit queue.
// Given two arrays of length n, time[] and direction[] such that time[i] represents 
// the time when person_i reaches the gate and direction[i] represents whether the 
// person is joining the entrance queue or exit queue, output an array timestamp[] 
// of length n such that timestamp[i] represents the time when person_i crosses the 
// gate. The gate operates as follows:
// If the gate was used at time t - 1 for entrance, then entry queue will be preferred.
// Else If the gate was used at time t - 1 for exit, then exit queue will be preferred.
// Else exit queue will be preferred.
// 1 <= n <= 10^5
// 1 <= time[i] <= 10^9
// time[i] <= time[i+1]
// direction[i] = 0 means entrance, direction[i] = 1 means exit.
// O(n)
// 
vector<int> getTimeStamps(vector<int> time, vector<int> dir) {
    int n = time.size();
    time.push_back(1E9 + 1E6);
    vector<int> out(n);
    queue<int> q[2]; // enter(0), exit(1)
    for (int i = 0, t = time[0], fl = -1; i < n; i++) {
        q[dir[i]].push(i);
        while (t < time[i + 1]) {
            if (not q[0].empty() and not fl) {
                out[q[0].front()] = t++;
                q[0].pop();
                fl = 0;
            }
            else if (not q[1].empty()) {
                out[q[1].front()] = t++;
                q[1].pop();
                fl = 1;
            }
            else if (not q[0].empty()) {
                out[q[0].front()] = t++;
                q[0].pop();
                fl = 0;
            }
            else {
                t = time[i + 1];
                fl = -1;
            }
        }
    }
    return out;
}

#-----------------------
# tower research
#include <bits/stdc++.h>
using namespace std;
 
int main() 
{
    int n;
    cin >> n;
    string arr[n];
    for (int i=0; i<n; i++)
        cin >> arr[i];
    // int check[26][2] = {0};
    vector < vector <int>> check;
    check.resize (26, vector <int> (2, 0));
    map < vector < vector <int> >, int > mp;
    for (int i=0; i<n; i++)
    {
        for (int j=0; j<arr[i].size(); j++)
        {
            check[arr[i][j] - 'a'][j%2]++;
        }
        mp[check]++;
    }
    // your code goes here
    cout << mp.size();
    return 0;
}


#--------------------
# BFS
// Program to print BFS traversal from a given 
// source vertex. BFS(int s) traverses vertices  
// reachable from s. 
#include<iostream> 
#include <list> 
  
using namespace std; 
  
// This class represents a directed graph using 
// adjacency list representation 
class Graph 
{ 
    int V;    // No. of vertices 
  
    // Pointer to an array containing adjacency 
    // lists 
    list<int> *adj;    
public: 
    Graph(int V);  // Constructor 
  
    // function to add an edge to graph 
    void addEdge(int v, int w);  
  
    // prints BFS traversal from a given source s 
    void BFS(int s);   
}; 
  
Graph::Graph(int V) 
{ 
    this->V = V; 
    adj = new list<int>[V]; 
} 
  
void Graph::addEdge(int v, int w) 
{ 
    adj[v].push_back(w); // Add w to v’s list. 
} 
  
void Graph::BFS(int s) 
{ 
    // Mark all the vertices as not visited 
    bool *visited = new bool[V]; 
    for(int i = 0; i < V; i++) 
        visited[i] = false; 
  
    // Create a queue for BFS 
    list<int> queue; 
  
    // Mark the current node as visited and enqueue it 
    visited[s] = true; 
    queue.push_back(s); 
  
    // 'i' will be used to get all adjacent 
    // vertices of a vertex 
    list<int>::iterator i; 
  
    while(!queue.empty()) 
    { 
        // Dequeue a vertex from queue and print it 
        s = queue.front(); 
        cout << s << " "; 
        queue.pop_front(); 
  
        // Get all adjacent vertices of the dequeued 
        // vertex s. If a adjacent has not been visited,  
        // then mark it visited and enqueue it 
        for (i = adj[s].begin(); i != adj[s].end(); ++i) 
        { 
            if (!visited[*i]) 
            { 
                visited[*i] = true; 
                queue.push_back(*i); 
            } 
        } 
    } 
} 
  
// Driver program to test methods of graph class 
int main() 
{ 
    // Create a graph given in the above diagram 
    Graph g(4); 
    g.addEdge(0, 1); 
    g.addEdge(0, 2); 
    g.addEdge(1, 2); 
    g.addEdge(2, 0); 
    g.addEdge(2, 3); 
    g.addEdge(3, 3); 
  
    cout << "Following is Breadth First Traversal "
         << "(starting from vertex 2) \n"; 
    g.BFS(2); 
  
    return 0; 
} 

#---------------------
# DFS
// C++ program to print DFS traversal for a given given graph 
#include<iostream> 
#include         <list> 
using namespace std; 
  
class Graph 
{ 
    int V;    // No. of vertices 
    list<int> *adj;    // Pointer to an array containing adjacency lists 
    void DFSUtil(int v, bool visited[]);  // A function used by DFS 
public: 
    Graph(int V);   // Constructor 
    void addEdge(int v, int w);   // function to add an edge to graph 
    void DFS();    // prints DFS traversal of the complete graph 
}; 
  
Graph::Graph(int V) 
{ 
    this->V = V; 
    adj = new list<int>[V]; 
} 
  
void Graph::addEdge(int v, int w) 
{ 
    adj[v].push_back(w); // Add w to v’s list. 
} 
  
void Graph::DFSUtil(int v, bool visited[]) 
{ 
    // Mark the current node as visited and print it 
    visited[v] = true; 
    cout << v << " "; 
  
    // Recur for all the vertices adjacent to this vertex 
    list<int>::iterator i; 
    for(i = adj[v].begin(); i != adj[v].end(); ++i) 
        if(!visited[*i]) 
            DFSUtil(*i, visited); 
} 
  
// The function to do DFS traversal. It uses recursive DFSUtil() 
void Graph::DFS() 
{ 
    // Mark all the vertices as not visited 
    bool *visited = new bool[V]; 
    for (int i = 0; i < V; i++) 
        visited[i] = false; 
  
    // Call the recursive helper function to print DFS traversal 
    // starting from all vertices one by one 
    for (int i = 0; i < V; i++) 
        if (visited[i] == false) 
            DFSUtil(i, visited); 
} 
  
int main() 
{ 
    // Create a graph given in the above diagram 
    Graph g(4); 
    g.addEdge(0, 1); 
    g.addEdge(0, 2); 
    g.addEdge(1, 2); 
    g.addEdge(2, 0); 
    g.addEdge(2, 3); 
    g.addEdge(3, 3); 
  
    cout << "Following is Depth First Traversaln"; 
    g.DFS(); 
  
    return 0; 
} 
#------------------
# no. of islands
// Program to count islands in boolean 2D matrix 
#include <stdbool.h> 
  
#define ROW 5 
#define COL 5 
  
// A function to check if a given cell (row, col) can be included in DFS 
int isSafe(int M[][COL], int row, int col, bool visited[][COL]) 
{ 
    return (row >= 0) && (row < ROW) &&      
           (col >= 0) && (col < COL) &&       
           (M[row][col] && !visited[row][col]);  
} 
  
// A utility function to do DFS for a 2D boolean matrix. It only considers 
// the 8 neighbours as adjacent vertices 
void DFS(int M[][COL], int row, int col, bool visited[][COL]) 
{ 
    static int rowNbr[] = {-1, -1, -1,  0, 0,  1, 1, 1}; 
    static int colNbr[] = {-1,  0,  1, -1, 1, -1, 0, 1}; 
  
    visited[row][col] = true; 
  
    for (int k = 0; k < 8; ++k) 
        if (isSafe(M, row + rowNbr[k], col + colNbr[k], visited) ) 
            DFS(M, row + rowNbr[k], col + colNbr[k], visited); 
} 
  
int countIslands(int M[][COL]) 
{ 
    bool visited[ROW][COL]; 
    memset(visited, 0, sizeof(visited)); 
  
    int count = 0; 
    for (int i = 0; i < ROW; ++i) 
        for (int j = 0; j < COL; ++j) 
            if (M[i][j] && !visited[i][j]) 
            {DFS(M, i, j, visited);++count;}
    return count; 
} 
  
// Driver program to test above function 
int main() 
{ 
    int M[][COL]= {  {1, 1, 0, 0, 0}, 
        {0, 1, 0, 0, 1}, 
        {1, 0, 0, 1, 1}, 
        {0, 0, 0, 0, 0}, 
        {1, 0, 1, 0, 1} 
    }; 
  
    printf("Number of islands is: %d\n", countIslands(M)); 
  
    return 0; 
} 
#---------------------
# detect cycle
// A C++ Program to detect cycle in an undirected graph 
#include <list> 
#include <limits.h> 
// Class for an undirected graph 
class Graph 
{ 
    int V;    // No. of vertices 
    list<int> *adj;    // Pointer to an array containing adjacency lists 
    bool isCyclicUtil(int v, bool visited[], int parent); 
public: 
    Graph(int V);   // Constructor 
    void addEdge(int v, int w);   // to add an edge to graph 
    bool isCyclic();   // returns true if there is a cycle 
}; 
  
Graph::Graph(int V) 
{ 
    this->V = V; 
    adj = new list<int>[V]; 
} 
  
void Graph::addEdge(int v, int w) 
{ 
    adj[v].push_back(w); // Add w to v’s list. 
    adj[w].push_back(v); // Add v to w’s list. 
} 
  
// A recursive function that uses visited[] and parent to detect 
// cycle in subgraph reachable from vertex v. 
bool Graph::isCyclicUtil(int v, bool visited[], int parent) 
{ 
    visited[v] = true; 
    list<int>::iterator i; 
    for (i = adj[v].begin(); i != adj[v].end(); ++i) 
    { 
        if (!visited[*i]) 
        { 
           if (isCyclicUtil(*i, visited, v)) 
              return true; 
        } 
        else if (*i != parent) 
           return true; 
    } 
    return false; 
} 
  
// Returns true if the graph contains a cycle, else false. 
bool Graph::isCyclic() 
{ 
    bool *visited = new bool[V]; 
    for (int i = 0; i < V; i++) 
        visited[i] = false; 
  
    for (int u = 0; u < V; u++) 
        if (!visited[u]) // Don't recur for u if it is already visited 
          if (isCyclicUtil(u, visited, -1)) 
             return true; 
  
    return false; 
} 
  
int main() 
{ 
    Graph g1(5); 
    g1.addEdge(1, 0); 
    g1.addEdge(0, 2); 
    g1.addEdge(2, 0); 
    g1.addEdge(0, 3); 
    g1.addEdge(3, 4); 
    g1.isCyclic()? cout << "Graph contains cycle\n": 
                   cout << "Graph doesn't contain cycle\n"; 
  
    Graph g2(3); 
    g2.addEdge(0, 1); 
    g2.addEdge(1, 2); 
    g2.isCyclic()? cout << "Graph contains cycle\n": 
                   cout << "Graph doesn't contain cycle\n"; 
  
    return 0; 
} 
#-------------------
# left view of tree
void leftViewUtil(struct node *root, int level, int *max_level) 
{ 
    if (root==NULL)  return; 
    if (*max_level < level) 
    { 
        printf("%d\t", root->data); 
        *max_level = level; 
    } 
  
    leftViewUtil(root->left, level+1, max_level); 
    leftViewUtil(root->right, level+1, max_level); 
} 
  
void leftView(struct node *root) 
{ 
    int max_level = 0; 
    leftViewUtil(root, 1, &max_level); 
} 
#----------------
# right view
void rightViewUtil(struct Node *root, int level, int *max_level) 
{ 
    if (root==NULL)  return; 
  
    if (*max_level < level) 
    { 
        printf("%d\t", root->data); 
        *max_level = level; 
    } 
  
    rightViewUtil(root->right, level+1, max_level); 
    rightViewUtil(root->left, level+1, max_level); 
} 
  
void rightView(struct Node *root) 
{ 
    int max_level = 0; 
    rightViewUtil(root, 1, &max_level); 
} 
#------------
# top view
void topview(Node* root) 
{ 
    if(root==NULL) 
       return; 
     queue<Node*>q; 
     map<int,int> m;  
     int hd=0; 
     root->hd=hd; 
    q.push(root); 
      
    cout<< "The top view of the tree is : \n"; 
      
    while(q.size()) 
    { 
        hd=root->hd; 
        if(m.count(hd)==0)   
        m[hd]=root->data; 
        if(root->left) 
        { 
            root->left->hd=hd-1; 
            q.push(root->left); 
        } 
        if(root->right) 
        { 
            root->right->hd=hd+1; 
            q.push(root->right); 
        } 
        q.pop(); 
        root=q.front(); 
        
    } 
      
      
      
     for(auto i=m.begin();i!=m.end();i++) 
    { 
        cout<<i->second<<" "; 
    } 
      
}

#----------------
# day of valid date
int day_of_the_week(int y, int m, int d){ 
    int t[] = { 0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4 }; 
    if (m < 3) y -= 1; 
 
    return ((y + y / 4 - y / 100 + y / 400 + t[m - 1] + d) % 7); 
} 
 
bool isLeap(int year){ 
    return (((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0)); 
} 
 
bool valid(int d, int m, int y){ 
 
    if (m < 1 || m > 12 || d < 1 || d > 31) return false; 
    if (m == 2){ 
        if (isLeap(y)) return (d <= 29); 
        else return (d <= 28); 
    } 
 
    if (m == 4 || m == 6 || m == 9 || m == 11) return (d <= 30); 
 
    return true; 
} 
 
int main(){ 
    int day = 13, month = 7, year = 2017; 
    if(valid(day, month, year))
        cout<<(day_of_the_week(year, month, day));
    else cout<<-1<<endl;
    return 0 ; 
} 
#----------------------
#Next Greater Number with same set of digit

#include <bits/stdc++.h>
using namespace std;
int findNext(string str){
    int n = str.size(), i;
 
    for(i=n-1; i>0; i--)
        if(str[i]>str[i-1]) break;
 
    if(i==0) return -1;
 
    //STL MAGIC
    reverse(str.begin()+i, str.end());
    auto x = upper_bound(str.begin()+i, str.end(), str[i-1]);
    swap(str[i-1], *x);
 
    long res = stol(str);
    if(res>INT_MAX) return -1;
    return res;
 
}
 
int main(){
    string digits = "19876"; 
 
    cout<<findNext(digits); 
 
    /* BOOM 
    One line code:
    
    next_permutation(digits.begin(), digits.end());  
    cout<<digits<<endl; //Check for next greater and then print. Next Permutation of 321 is 123. 123<321
 
    return 0; 
} 

#-------------------
# sum of cousin node given root and a node
void findlevel(Node* root, int key, int curr, int &level){
    if(!root || level!=-1) return;
    if(root->data==key){
        level=curr;
        return;
    }
 
    findlevel(root->left, key, curr+1, level);
    findlevel(root->right, key, curr+1, level);
}
 
 
void findsum(Node* root, int &sum, int level, int curr, int key){
    if(!root || curr>level) return;
 
    if(curr==level) sum+=root->data;
 
    if(root->left && root->right){
        if(root->left->data!=key && root->right->data!=key){
            findsum(root->left, sum, level, curr+1,key);
            findsum(root->right, sum, level, curr+1,key);
        }
    }
 
    else if(root->left){
        if(root->left->data!=key)
            findsum(root->left, sum, level, curr+1,key);
    }
 
    else if(root->right){
        if(root->right->data!=key)
        findsum(root->right, sum, level, curr+1,key);
    }
}
 
int findCousinSum(Node* root, int key){
    int level = -1;
    findlevel(root, key, 0, level);
    if(level==-1) return -1;
 
    int sum = 0;
    findsum(root, sum, level, 0, key);
    return sum;
}

#----- UBER -----
#BALLOT - Distributing Ballot Boxes

#include <cstdio>
#include <algorithm>

using namespace std;

int main(){
    int N,B,a[500000];
    
    while(true){
        scanf("%d %d",&N,&B);
        if(N == -1) break;
        
        int lo = 1,hi = 0,mi;
        
        for(int i = 0;i < N;++i){
            scanf("%d",&a[i]);
            hi = max(hi,a[i]);
        }
        
        while(lo < hi){
            mi = (lo + hi) >> 1;
            
            int cont = 0;
            
            for(int i = 0;i < N;++i)
                cont += (a[i] + mi - 1) / mi;
            
            if(cont > B) lo = mi + 1;
            else hi = mi;
        }
        
        printf("%d\n",lo);
    }
    
    return 0;
}
#---- martian mining ----
#include <cstdio>
#include <algorithm>

using namespace std;

int n,m,P1[500][500],P2[500][500],FR[501][501],FC[501][501],dp[501][501];

int main(){
    while(1){
        scanf("%d %d",&n,&m);
        if(n==0) break;
        
        for(int i=0;i<n;i++)
            for(int j=0;j<m;j++)
                scanf("%d",&P1[i][j]);
        
        for(int i=0;i<n;i++)
            for(int j=0;j<m;j++)
                scanf("%d",&P2[i][j]);
        
        for(int i=0;i<=m;i++) FR[i][0]=0;
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++)
                FR[i][j]=FR[i][j-1]+P1[i-1][j-1];
        
        for(int i=0;i<=n;i++) FC[0][i]=0;
        for(int i=1;i<=n;i++)
            for(int j=1;j<=m;j++)
                FC[i][j]=FC[i-1][j]+P2[i-1][j-1];
        
        for(int i=0;i<=m;i++) FC[0][i]=0;
        for(int i=0;i<=n;i++) FR[i][0]=0;
        
        for(int i=1;i<=m;i++)
            for(int j=1;j<=n;j++)
                dp[i][j]=max(dp[i-1][j]+FR[i][j],dp[i][j-1]+FC[i][j]);
        
        printf("%d\n",dp[n][m]);
    }
    
    return 0;
}

#---- first & last occ. of num. in sorted arr - O(N)
/* if x is present in arr[] then returns the index of 
   FIRST occurrence of x in arr[0..n-1], otherwise 
   returns -1 
int first(int arr[], int low, int high, int x, int n) 
{ 
    if(high >= low) 
    { 
        int mid = low + (high - low)/2; 
        if( ( mid == 0 || x > arr[mid-1]) && arr[mid] == x) 
            return mid; 
        else if(x > arr[mid]) 
            return first(arr, (mid + 1), high, x, n); 
        else
            return first(arr, low, (mid -1), x, n); 
    } 
    return -1; 
} 
  
  
/* if x is present in arr[] then returns the index of 
   LAST occurrence of x in arr[0..n-1], otherwise 
   returns -1 
int last(int arr[], int low, int high, int x, int n) 
{ 
    if (high >= low) 
    { 
        int mid = low + (high - low)/2; 
        if (( mid == n-1 || x < arr[mid+1]) && arr[mid] == x) 
            return mid; 
        else if (x < arr[mid]) 
            return last(arr, low, (mid -1), x, n); 
        else
            return last(arr, (mid + 1), high, x, n); 
    } 
    return -1; 
}

#---- valid sudoko -----
bool notInRow(char arr[][9], int row) 
{ 
    // Set to store characters seen so far. 
    set<char> st; 
  
    for (int i = 0; i < 9; i++) { 
  
        // If already encountered before, return false 
        if (st.find(arr[row][i]) != st.end()) 
            return false; 
  
        // If it is not an empty cell, insert value 
        // at the current cell in the set 
        if (arr[row][i] != '.') 
            st.insert(arr[row][i]); 
    } 
    return true; 
} 
  
// Checks whether there is any duplicate 
// in current column or not. 
bool notInCol(char arr[][9], int col) 
{ 
    set<char> st; 
  
    for (int i = 0; i < 9; i++) { 
  
        // If already encountered before, return false 
        if (st.find(arr[i][col]) != st.end()) 
            return false; 
  
        // If it is not an empty cell, 
        // insert value at the current cell in the set 
        if (arr[i][col] != '.') 
            st.insert(arr[i][col]); 
    } 
    return true; 
} 
  
// Checks whether there is any duplicate 
// in current 3x3 box or not. 
bool notInBox(char arr[][9], int startRow, int startCol) 
{ 
    set<char> st; 
  
    for (int row = 0; row < 3; row++) { 
        for (int col = 0; col < 3; col++) { 
            char curr = arr[row + startRow][col + startCol]; 
  
            // If already encountered before, return false 
            if (st.find(curr) != st.end()) 
                return false; 
  
            // If it is not an empty cell, 
            // insert value at current cell in set 
            if (curr != '.') 
                st.insert(curr); 
        } 
    } 
    return true; 
} 
  
// Checks whether current row and current column and 
// current 3x3 box is valid or not 
bool isValid(char arr[][9], int row, int col) 
{ 
    return notInRow(arr, row) && notInCol(arr, col) && 
           notInBox(arr, row - row % 3, col - col % 3); 
} 
  
bool isValidConfig(char arr[][9], int n) 
{ 
    for (int i = 0; i < n; i++) { 
        for (int j = 0; j < n; j++) { 
  
            // If current row or current column or 
            // current 3x3 box is not valid, return false 
            if (!isValid(arr, i, j)) 
                return false; 
        } 
    } 
    return true; 
}

#---- roman to decimal
// This function returns value of a Roman symbol 
int value(char r) 
{ 
    if (r == 'I')return 1;if(r == 'V')return 5; if(r == 'X')return 10; 
    if (r == 'L')return 50;if (r == 'C')return 100;if (r == 'D')return 500; 
    if (r == 'M')return 1000;return -1; 
} 
// Returns decimal value of roman numaral 
int romanToDecimal(string &str) 
{ 
    // Initialize result 
    int res = 0; 
  
    // Traverse given input 
    for (int i=0; i<str.length(); i++) 
    { 
        // Getting value of symbol s[i] 
        int s1 = value(str[i]); 
  
        if (i+1 < str.length()) 
        { 
            // Getting value of symbol s[i+1] 
            int s2 = value(str[i+1]); 
  
            // Comparing both values 
            if (s1 >= s2) 
            { 
                res = res + s1; 
            } 
            else
            { 
                res = res + s2 - s1;i++;
            } 
        } 
        else
        { 
            res = res + s1; 
            i++; 
        } 
    } 
    return res; 
} 

#--- uber vacation ---
// This class represents a undirected graph using adjacency 
// list representation 
class Graph 
{ 
    int V;    // No. of vertices 
    list<int> *adj; 
public: 
    Graph(int V);  // Constructor 
    void addEdge(int u, int v); 
    bool DFSUtil(int, vector<bool> &, vector<int> &, int k); 
    void printKCores(int k); 
}; 
bool Graph::DFSUtil(int v, vector<bool> &visited,vector<int> &vDegree, int k) 
{ 
    visited[v] = true; 
    list<int>::iterator i; 
    for (i = adj[v].begin(); i != adj[v].end(); ++i) 
    { 
        if (vDegree[v] < k) 
            vDegree[*i]--; 
  
        if (!visited[*i]) 
        { 
            if (DFSUtil(*i, visited, vDegree, k)) 
                vDegree[v]--; 
        } 
    } 
    return (vDegree[v] < k); 
} 
  
Graph::Graph(int V) 
{ 
    this->V = V; 
    adj = new list<int>[V]; 
} 
  
void Graph::addEdge(int u, int v) 
{ 
    adj[u].push_back(v); 
    adj[v].push_back(u); 
} 
  
void Graph::printKCores(int k) 
{ 
    vector<bool> visited(V, false); 
    vector<bool> processed(V, false); 
  
    int mindeg = INT_MAX; 
    int startvertex; 
  
    vector<int> vDegree(V); 
    for (int i=0; i<V; i++) 
    { 
        vDegree[i]  = adj[i].size(); 
  
        if (vDegree[i] < mindeg) 
        { 
            mindeg = vDegree[i]; 
            startvertex=i; 
        } 
    } 
  
    DFSUtil(startvertex, visited, vDegree, k); 
    for (int i=0; i<V; i++) 
        if (visited[i] == false) 
            DFSUtil(i, visited, vDegree, k); 
  
    cout << "K-Cores : \n"; 
    for (int v=0; v<V; v++) 
    { 
        if (vDegree[v] >= k) 
        { 
            cout << "\n[" << v << "]"; 
            list<int>::iterator itr; 
            for (itr = adj[v].begin(); itr != adj[v].end(); ++itr) 
                if (vDegree[*itr] >= k) 
                    cout << " -> " << *itr; 
        } 
    } 
} 
int main() 
{ 
    int k = 3; 
    Graph g1(9); 
    g1.addEdge(0, 1); 
    . . .
    g1.printKCores(k);   
    return 0; 
} 
#------ team formation -----
#define MAXN 100000
int a[MAXN],b[MAXN];
vector<int> have;
int solve(int l, int r){
    int n = 0;
    for(int i = l;i <= r;){
        int e = i;
        while(e <= r && a[e] == a[i]) ++e;
        b[n++] = e - i;
        i = e;
    }
    int ans = 100000,m = 0;
    for(int i = 0;i < n;++i){
        if(b[i] < m){
            for(int j = m - b[i];j >= 1;--j){
                ans = min(ans,have.back());
                have.pop_back();
            }
        }else{
            for(int j = b[i] - m;j >= 1;--j)
                have.push_back(0);
        }
        m = b[i];
        for(int j = m - 1;j >= 0;--j)
            ++have[j];
        sort(have.begin(),have.end());
    }
    if(!have.empty())
        ans = min(ans,have[0]);
    have.clear();
    return ans;
}
int main(){
    ios::sync_with_stdio(0);
    int T,n;
    cin >> T;
    while(T--){
        cin >> n;
        for(int i = 0;i < n;++i)
            cin >> a[i];
        sort(a,a + n);
        int ans = 100000;
        for(int i = 0;i < n;){
            int e = i + 1;
            while(e < n && a[e] - a[e - 1] <= 1) ++e;
            ans = min(ans,solve(i,e - 1));
            i = e;
        }
        if(n == 0) ans = 0;
        cout << ans << '\n';
    }
    return 0;
}

#---- segregating even and odd number ----
// CPP code to segregate even odd 
// numbers in an array 
#include <bits/stdc++.h> 
using namespace std; 
  
// Function to segregate even odd numbers 
void arrayEvenAndOdd(int arr[], int n) 
{ 
  
    int i = -1, j = 0; 
    int t; 
    while (j != n) { 
        if (arr[j] % 2 == 0) { 
            i++; 
  
            // Swapping even and odd numbers 
            swap(arr[i], arr[j]); 
        } 
        j++; 
    } 
  
    // Printing segregated array 
    for (int i = 0; i < n; i++) 
        cout << arr[i] << " "; 
}


#---- factorial of a large number ----
#define MAX 500 
int multiply(int x, int res[], int res_size); 
void factorial(int n) 
{ 
    int res[MAX]; 
    res[0] = 1; 
    int res_size = 1; 
    for (int x=2; x<=n; x++) 
        res_size = multiply(x, res, res_size); 
    cout << "Factorial of given number is \n"; 
    for (int i=res_size-1; i>=0; i--) 
        cout << res[i]; 
} 
int multiply(int x, int res[], int res_size) 
{ 
    int carry = 0;  // Initialize carry 
    for (int i=0; i<res_size; i++) 
    { 
        int prod = res[i] * x + carry; 
        res[i] = prod % 10;   
        carry  = prod/10;     
    } 
    while (carry) 
    { 
        res[res_size] = carry%10; 
        carry = carry/10; 
        res_size++; 
    } 
    return res_size; 
} 
int main(){factorial(100);return 0;}

#---- maximum diff. sum
const long long int MOD = 1000000007; 
  
// function for sum of max min difference  
int maxMin (int arr[], int n)  
{ 
    // sort all numbers 
    sort(arr, arr + n); 
      
    // iterate over array and with help of  
    // horner's rule calc max_sum and min_sum 
    long long int min_sum = 0, max_sum = 0; 
    for (int i = 0; i < n; i++) 
    { 
        max_sum = 2 * max_sum + arr[n-1-i]; 
        max_sum %= MOD; 
        min_sum = 2 * min_sum + arr[i]; 
        min_sum %= MOD; 
    } 
  
    return max_sum - min_sum; 
}

#---- gray code from 0 to 2^n-1
// This function generates all n bit Gray codes and prints the 
// generated codes 
void generateGrayarr(int n) 
{ 
    if (n <= 0) 
        return; 
    vector<string> arr; 
    arr.push_back("0"); 
    arr.push_back("1"); 
  
    int i, j; 
    for (i = 2; i < (1<<n); i = i<<1) 
    { 
        for (j = i-1 ; j >= 0 ; j--) 
            arr.push_back(arr[j]); 
        for (j = 0 ; j < i ; j++) 
            arr[j] = "0" + arr[j]; 
        for (j = i ; j < 2*i ; j++) 
            arr[j] = "1" + arr[j]; 
    } 
    for (i = 0 ; i < arr.size() ; i++ ) 
        cout << arr[i] << endl; 
}

#---- different sequence of scores in volleyball match ----
Define NumScores(A,B):
    If A=0 and B=0, return 1
    Else If A<0 or B<0, return 0
    Else If A<25 and B<25, return NumScores(A-1,B) + NumScores(A,B-1)
    Else If |A-B|>1, return 0
    Else return NumScores(A-1,B) + NumScores(A,B-1)

#---- immediate smallest ----
void immediateSmallest(string s) 
{ 
    int l = s.size(); 
    for (int i = l - 1; i > 0; i--) { 
        if (s[i] < s[i - 1]) { 
            swap(s[i], s[i - 1]); 
            cout << s; 
            return; 
        } 
    } 
    cout << "Not Possible\n"; 
} 
int main() 
{ 
    int n = 3532; 
    string s = to_string(n); 
    immediateSmallest(s); 
} 

#---- two trees are mirror or not ----
int areMirror(Node* a, Node* b) 
{ 
    /* Base case : Both empty
    if (a==NULL && b==NULL) 
        return true; 
  
    // If only one is empty 
    if (a==NULL || b == NULL) 
        return false; 
  
    /* Both non-empty, compare them recursively 
     Note that in recursive calls, we pass left 
     of one tree and right of other tree
    return  a->data == b->data && 
            areMirror(a->left, b->right) && 
            areMirror(a->right, b->left); 
} 
# ---- 
*/

